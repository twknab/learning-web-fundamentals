The Repository
The repository is the place where the version control system keeps track of all the changes you make. Most Version Control Systems (VCS) store the current state of the code, along with when each change was made, who made it, and a text log message that explains why they made the change.

You can think of a repository like a bank vault and its history like the ledger. Each time a deposit—what is called a commit in VCS lingo—is made, your VCS tool adds an entry to the ledger and stores the changes for safe keeping.

Working Trees

So far we’ve discussed the repository and talked about all the files you’re storing in it, but we haven’t talked about where you make all of your changes. This happens in your working tree.

The working tree is your current view into the repository. It has all the files from your project: the source code, build files, unit tests, and so on.

Creating your first version controlled project

1) Creating a Repository

First we create a folder to house our project and navigate to that folder.

mkdir new_project
cd new_project
To create a repository, all we need to do is type:

git init
which initializes a repository in that folder.

The repository is simply a new sub-directory named  .git that contains all of your necessary repository files in your project's directory. Right now the repository is empty.

2) Making Changes

Now create a file in that directory called index.html with the content

<html>
  <head></head>
  <body>
    <h1>Hello Git</h1>
  </body>
</html>
The current state of index.html is  modified.

To change the state to  staged (which means ready to be committed), we tell Git to add the file to its index.

git add index.html
Now to take a snapshot of the current state of all the staged files, we run:

git commit -m "index.html added"
And the state of index.html becomes  committed.

Commits are the individual pieces of history stored by the repository. Each one marks the progression of your code. Git stores your name and email address—from the configuration we did earlier—and adds a message to each commit.

That’s what the  -m and string in the earlier command are for. The commit message is 'index.html added'. Properly written log messages are the killer feature of any version control system. They’re a place to explain the reason of your commit. What does the new file do? Why did you change the code?

Now to see the list of your commits, you can run the command

git log
This will give you a list of all your commits & the messages you put in. Here's an example:

commit bdf8ce93d2af928e8a430629225e3bd754429bd8
Author: Eylem Ozaslan <eylem.ozaslan@gmail.com>
Date: Sun Jun 30 09:52:58 2013 -0700
     index.html added
The first line here shows the commit name. Commit names are SHA- 1 hashes generated by Git to keep track of a commit. Git uses these hashes to make sure that each commit identifier is completely unique.  (Tip: The first leading seven characters that are displayed by git log are normally unique enough that you can use them without having to use the full forty-character hash.)

The second line in the git log output is the commit’s author info, the third is the date the commit was made, and the final bit of information is the commit log message from the commit.


Making Changes
Tracking changes to your files over time is the whole reason for using a VCS. You make changes to the source code, re-run your unit tests to make sure your changes don’t have any side effects, and then commit those changes.

Committing a change adds a new revision to the repository and stores your log message explaining what the change did. This gives you a record to go back through if you ever need to figure out why a certain change was made or when a bug was introduced.

Let's make some changes to our index.html file and add some information to our head.

<html>
  <head>
    <meta charset="UTF-8">
    <title>Version Control</title>
  </head>
  <body>
    <h1>Hello Git</h1>
  </body>
</html>
Now that we've made changes to our file, its state is  modified again.

What if we forget what state our files are in? Git has a status command that allows us to see what's going on in our working tree:

git status
This should return something like:

#On branch master
#Changes not staged for commit:
  modified: index.html
  no changes added to commit (use "git add" and/or "git commit -a")
Now, if we add index.html to the staging area:

git add index.html
and run the status command again:

git status
it will return something like this:

# On branch master
# Changes to be committed:
#     (use "git reset HEAD <file>..." to unstage)
#     modified: index.html</file>
Now, to commit these changes:

git commit -m "added meta charset and title tag to index.html"

Looking at the Past
Your Commit History
The commit log is the most common way for you to inspect what has happened to your repository. Git shows each new commit’s log entry, along with who made the commit, when, and optionally the changes that were made.

It’s displayed in a reverse chronological order, like a blog. You can provide all sorts of parameters to filter the log, but let’s start with the basics. Just type git log at the command prompt from within your working tree:

git log
commit 0bb3dfb752fa3c890ffc781fd6bd5dc5d34cd3be
Author: John Doe <johndoe@gmail.com>
Date: Sat Oct 4 11:06:47 2008 -0500
added css file for index.html
commit 18f822eb1044761f59aebaf7739261042ae10392
Author: John Doe <johndoe@gmail.com>
Date: Fri Oct 3 10:16:27 2008 -0500
added index.html
The number after the 'commit' text is called the commit hash and it's what we use to refer to a particular commit.
Sometimes our log messages aren’t as descriptive as we thought they were when we view them six months later. Often, viewing the code that changed in conjunction with the log message can help jog our memories. Adding the -p option tells Git to display the diff that revision created.
Often you need to view only a set number of commits. You can add -1 to the log command to limit the log to one commit, -2 to limit it to two commits, and so on. For example, git log -10 shows the last ten log entries.
Looking at How Much Has Been Changed:

There’s another cool option for git diff that prints some statistics about the changes that have been made. Just add the --stat option to see what changes have been made since a particular commit.

Ex: To see how much has changed since commit 18f822eb1044761f59aebaf7739261042ae10392, we run:

git diff --stat 18f822eb1044761f59aebaf7739261042ae10392
about.html   |
contact.html |
hello.html   |
index.html   |
4 files changed, 51 insertions(+), 9 deletions(-)
15 +++++++++++++++
23 +++++++++++++++++++++++
13 +++++++++++++
  9 ---------<br />
This is a great way to see the amount of code that has been touched since a particular commit.

Reverting
Before we start, here's a word of caution: be careful how you use the commands in this section if you use Git as a centralized repository and push every commit back upstream. Changing the history after you’ve shared it can lead to major headaches when others try to sync against your changes.

(This paragraph will make sense once you're familiar with Github!) One of the values of completely distributed development is that you share only what is ready. Make sure changes are ready before you push them. By keeping all your changes local until they are ready, you leave yourself the option of rewriting your repository’s history without worrying how it affects others.

There are 2 ways to rollback to a previous commit: revert and reset. We will first go over revert, and it's recommended that you  try to use revert over reset whenever possible.

REVERT
Sometimes code doesn’t work out. It requires a certain architecture or introduces a new third-party software dependency that the rest of the team isn’t on board with. If you’ve committed your changes already, you need to undo the commits with the new change or revert them.

The simplest way to revert an existing commit is the git revert command. It “reverts” a commit by creating a new commit in your repository that  reverses all the changes made by the original commit.

Normally Git commits the reversal immediately, but you can add the -n parameter to tell Git not to commit. This is useful when you need to revert multiple commits. Just run multiple git revert commands with the -n parameter, and Git stages all the changes and waits for you to commit them.

You must provide it with a commit name so it knows what to revert. For example, if you want to revert the commit 540ecb7 and HEAD, use the following.  Always revert backward—the most recent first. That makes sure you don’t have any unnecessary conflicts to work through when reverting multiple commits.

git revert -n HEAD
Finished one revert.
git revert -n 540ecb7 
Removed copy.txt 
Finished one revert.
git commit -m "revert 45eaf98 and 540ecb7"
Created commit 2b3c1de: revert 45eaf98 and 540ecb7
2 files changed, 0 insertions(+), 10 deletions(-)
delete mode 100644 copy.txt
RESET
Right as you hit the Enter key, you realize you’ve just committed a configuration file with your private password in it. We’ve all been there.

Git assumes we make mistakes like this and allows us to reset the repository to the state we want with reset. The command git reset takes a commit name as its parameter or defaults to HEAD if you don’t provide one.

Or using a commit hash as a name to reset to a particular commit we run:

git reset <commit hash> --hard
Tip: So far we've been using the full hash whenever we needed to. However, the  first leading seven characters that are displayed by git log are normally unique enough that you can use them without having to use the full forty-character hash. So we can run something like this:

git reset 6c77676 --hard
If you only want to reset the changes to a particular file and not the whole project, you can run:

git reset <commit hash> <filename> --hard
Warning!!! When we revert the changes using this command, the changes we revert are GONE FOREVER, ERASED FROM THE LOG, UNRECOVERABLE. This is what makes reset perfect for those situations when you want to UTTERLY AND COMPLETELY ERASE SOMETHING, but A TERRIBLE IDEA FOR ANYTHING ELSE.

States
Git has three main states that your files can reside in: committed, modified, and staged.

- Modified: You have changed the file in your Working Directory but have not added it yet.

- Staged: You have marked a modified file to go into the Staging Area for your next commit.

- Committed: Data is safely stored from the Staging Area into your local .git Directory.

Working Directory: A single checkout of the project. These files are pulled out of the compressed database in the Git Directory and placed on disk for you to use or modify.
Staging Area: Is a simple file, generally contained in your Git directory, that stores information about what will go into your next commit -- basically an "index" of the staged files.
Git Directory (Repository): Metadata & Object Database of the project (a compressed reference "skeleton" of the project). This is the essential part of Git -- it's what is copied when you clone a repository from GitHub or another computer.
The basic Git workflow goes something like this:

You create a new file or modify existing files in your working tree.
You stage the files, by adding them to your staging area.
You do a commit, which takes the files as they are in the staging area and stores that snapshot permanently to your Git directory.
Let's look at what add and commit do in a little more detail.

Add: In Git, an add is what tells your repository, "hey, I want you to add these changes to the next version of the project!" You add files to the staging area to have them included in your next commit (see below). If you add a file and then make more changes to it, you must re-add the file to include all of your recent changes.

To add a file to the staging area you would do something like this:

// to add a specific file, index_html, to staging area:
git add index.html
// to add all changed files to the staging area
git add .
Commit: Once you feel your project has reached a point where it should be saved, you tell Git to commit all your files in the staging area. This means every file you have added will be updated with the changes you have made. With every commit, you create another local version of your project. Additionally, Git clears the staging area each time you do a commit.

git commit -m 'Name to identify commit goes here'

forking - similar to git clone but mainly used to create a copy of a repository/project that you can, then, modify independently without changing the original repository. This may be done with your own repository, someone else's open source repository, or a private repository that somebody else has shared with you.
pull request - once you've made your changes to your forked repo, you can make a pull request to the owner of the original repository you forked from. Afterwards, the owner will decide whether or not to include your changes into their repository.
git branch ___ - creates a new branch named ___
git merge ____ - tells Git to merge the codes in branch ____ to whatever branch you're currently on